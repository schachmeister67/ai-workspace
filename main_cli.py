import os
from dotenv import load_dotenv
from pydantic import BaseModel, Field
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_community.utilities import SQLDatabase
from langchain_community.agent_toolkits import SQLDatabaseToolkit
from langchain_core.tools import tool
from langchain_core.messages import HumanMessage
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.prebuilt import create_react_agent
from langgraph.types import Command
from typing import Literal

load_dotenv()

llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash")

db = SQLDatabase.from_uri(os.getenv("DATABASE_URL"))
toolkit = SQLDatabaseToolkit(db=db, llm=llm)
tools = toolkit.get_tools()
list_tables_tool = next(
    (tool for tool in tools if tool.name == "sql_db_list_tables"), None
)
get_schema_tool = next((tool for tool in tools if tool.name == "sql_db_schema"), None)


@tool
def db_exec_tool(query: str) -> str:
    """
    Execute a SQL query against the database and return the result.
    If the query is invalid or returns no result, an error message will be returned.
    In case of an error, the user is advised to rewrite the query and try again.
    """
    # Remove ```sql and ``` if present
    query = query.replace("```sql", "").replace("```", "").strip()

    # print("Executing query:")
    # print(query)

    result = db.run_no_throw(query)

    # print("Query result:")
    # print(result)

    return {"result": result}


class QueryChecker(BaseModel):
    query: str = Field(description="The corrected postgres query generated by the LLm")


def query_gen(state: MessagesState) -> Command[Literal["query_check"]]:
    """
    Query Generation Node to convert natural language database queries into PostgreSQL queries.

    Args:
        state (MessagesState): The current state containing the conversation history with a natural language database query.

    Returns:
        Command: A command to update the state with the generated PostgreSQL query.
    """
    # print("query_generator")
    # print(state["messages"][-1].content)

    if not list_tables_tool or not get_schema_tool:
        raise ValueError(
            "Required database tools (list_tables_tool, get_schema_tool) are not available"
        )

    # Create a system message for the agent
    system_prompt = (
        "You are an expert database query generator specialized in PostgreSQL. "
        "You are provided with tools to list the tables in the database and get the schema of specific tables. "
        "Always use the list_tables_tool first to get an overview of available tables. "
        "Then, for any relevant table(s), use the get_schema_tool to retrieve their schema before constructing the query. "
        "You can generate SQL queries for ANY database operation including: "
        "- Counting records, getting database metadata (current_database(), version(), etc.) "
        "- Selecting data from tables, aggregating data, joining tables "
        "- Getting system information about the database "
        "Ensure that the SQL query you generate is syntactically correct and follows PostgreSQL standards. "
        "Your final output should only be the SQL query, without any additional explanation or commentary. "
        "If a user asks for database name, use SELECT current_database(); "
        "If a user asks for database version, use SELECT version(); "
        "Be creative and use appropriate PostgreSQL system functions and queries to answer any question."
    )
    
    query_agent = create_react_agent(
        llm,  # The language model instance used by the agent
        tools=[
            list_tables_tool,
            get_schema_tool,
        ],  # List of database tools the agent can utilize
    )

    # Add system message to the state
    state_with_system = {
        "messages": [
            HumanMessage(content=system_prompt, name="system"),
            *state["messages"]
        ]
    }

    # Invoke the agent with the system prompt included
    result = query_agent.invoke(state_with_system)
    # print(result)
    return Command(
        update={
            "messages": [
                # Append the result to the state, tagged with "supervisor"
                HumanMessage(content=result["messages"][-1].content, name="supervisor")
            ]
        }
    )


def query_check(state: MessagesState) -> Command[Literal["query_execute"]]:
    """
    This tool checks if the provided SQL query is correct.
    If incorrect, it returns the corrected query; otherwise, it returns the original query.
    """
    query_check_system = """You are a SQL expert with a strong attention to detail.
    You work with PostgreSQL, SQLite, and other relational databases.
    Your task is to carefully review the provided SQL query for any mistakes, including:
    - Quoting identifiers correctly (e.g., "Snippet" vs Snippet in PostgreSQL)
    - Data type mismatches
    - Using the correct number of arguments in functions
    - Ensuring joins use valid columns
    - Checking for NULL handling issues
    - Ensuring correct usage of UNION vs UNION ALL
    - Proper casting and type usage
    Make sure that the final query is in a postgres acceptable format
    If there is an issue, respond with the **corrected query only**.
    If the query is already correct, simply return the **original query**.
    """
    query = state["messages"][-1].content

    full_prompt = f"{query_check_system}\n\nQuery:\n{query}"

    # LLM invocation
    response = llm.with_structured_output(QueryChecker).invoke(full_prompt)

    # print("query_Check")
    # print(response)
    
    return Command(
        update={
            "messages": [
                # Append the corrected query to the state, tagged with "supervisor"
                HumanMessage(content=response.query, name="supervisor")
            ]
        }
    )


def query_execute(state: MessagesState):
    """
    This tool executes the provided SQL query and return the response.
    It returns the response in simple human understandable format.
    """
    # print("state from query execute")
    # print(state)
    # Create a system message for the executing agent
    system_prompt = (
        "You are an expert PostgreSQL query executor. "
        "You can use db_exec_tool for execution of any SQL query including system queries. "
        "Your primary task is to execute the provided SQL query accurately and return the result. "
        "You can execute any type of PostgreSQL query including: "
        "- Data selection queries (SELECT) "
        "- System information queries (current_database(), version(), etc.) "
        "- Aggregate queries (COUNT, SUM, etc.) "
        "- Metadata queries about tables, schemas, etc. "
        "Execute the query exactly as provided and return the result in a clear, human-understandable format. "
        "Always provide the actual data/results, not just explanations. "
        "If the query returns system information like database name or version, present it clearly to the user."
    )
    
    executing_agent = create_react_agent(
        llm,  # The language model instance used by the agent
        tools=[db_exec_tool],  # List of database tools the agent can utilize
    )
    
    # Add system message to the state
    state_with_system = {
        "messages": [
            HumanMessage(content=system_prompt, name="system"),
            *state["messages"]
        ]
    }

    final_result = executing_agent.invoke(state_with_system)
    # parsed_result = QueryExecutor(result=final_result)  # Assuming `QueryExecutor` is a Pydantic model with a 'result' field
    # print(parsed_result)
    print(final_result["messages"][-1].content)
    return Command(
        update={
            "messages": [
                # Append the final result to the state, tagged with "supervisor"
                HumanMessage(
                    content=final_result["messages"][-1].content, name="supervisor"
                )
            ]
        }
    )


builder = StateGraph(MessagesState)

# Add edges and nodes to define the workflow of the graph
builder.add_node("query_gen", query_gen)
builder.add_node("query_check", query_check)
builder.add_node("query_execute", query_execute)

builder.add_edge(START, "query_gen")
builder.add_edge("query_gen", "query_check")
builder.add_edge("query_check", "query_execute")
builder.add_edge("query_execute", END)

graph = builder.compile()


def process_query(message: str) -> str:
    """
    Process a natural language query and return the database result.
    
    Args:
        message (str): The natural language query to process
        
    Returns:
        str: The result from the database in human-readable format
    """
    inputs = {"messages": [("user", message)]}
    final_output = ""

    for output in graph.stream(inputs):
        for key, value in output.items():
            if value is not None:
                final_output = value["messages"][-1].content
                
    print(f"Final output: {final_output}")
    return final_output

# Added interactive CLI interface: The main section now provides an interactive command-line interface where users can:

# Enter database queries in natural language
# See the results immediately
# Type 'quit', 'exit', or 'q' to stop the program

if __name__ == "__main__":
    # Interactive mode - keep asking for queries
    print("Database Query Assistant")
    print("Type 'quit' or 'exit' to stop")
    print("-" * 40)
    
    while True:
        user_input = input("\nEnter your database query: ").strip()
        
        if user_input.lower() in ['quit', 'exit', 'q']:
            print("Goodbye!")
            break
            
        if not user_input:
            print("Please enter a valid query.")
            continue
            
        try:
            result = process_query(user_input)
            print(f"\nResult: {result}")
        except Exception as e:
            print(f"Error processing query: {e}")
            print("Please try again with a different query.")
